package test.滑动窗口.hard;

/**
 * Created by mengyue on 2019-10-17.
 */
public class K连续位的最小翻转次数_995 {

    /**
     * 在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。
     *
     * 返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。
     *
     *  
     *
     * 示例 1：
     *
     * 输入：A = [0,1,0], K = 1
     * 输出：2
     * 解释：先翻转 A[0]，然后翻转 A[2]。
     * 示例 2：
     *
     * 输入：A = [1,1,0], K = 2
     * 输出：-1
     * 解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
     * 示例 3：
     *
     * 输入：A = [0,0,0,1,0,1,1,0], K = 3
     * 输出：3
     * 解释：
     * 翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
     * 翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
     * 翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
     *  
     *
     * 提示：
     *
     * 1 <= A.length <= 30000
     * 1 <= K <= A.length
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     *
     * @param args
     */
    public static void main(String[] args) {


        int[] A = {1, 0, 1, 1, 1, 0};


        int k = 1;


        System.out.println(minKBitFlips(A, k));

    }


    public static int minKBitFlips(int[] A, int K) {
        int N = A.length;
        int[] hint = new int[N];
        /**
         *
         * flip存在的意义 就是表名前一个数字 有没有被翻转
         *
         */
        int ans = 0, flip = 0;

        // 当我们翻转子数组形如 A[i], A[i+1], ..., A[i+K-1]
        // 我们可以在此位置置反翻转状态，并且在位置 i+K 设置一个提醒，告诉我们在那里也要置反翻转状态
        for (int i = 0; i < N; ++i) {

            /**
             * 相同为0 不同为1
             * 判断 这个位置 是否为奇数翻转,因为前面的翻转会将flip设置为1
             *
             * flip     hint[i]     A[i]
             * 0        0       ?=  0 1
             * 0        1       ?=  0 1
             * 1        0       ?=  0 1
             * 1        1       ?=  0 1
             *
             *
             *
             *
             */
            flip ^= hint[i];
            /**
             *
             * 判断flip是否为0 如果是的话 就需要对区间[i,i+k] 之间进行翻转了 其实也就是 hint[i + K] ^= 1
             *
             *
             *
             * 当 flip 为0，表示没有翻转，且原数组 A[i] 为0，此时就需要翻转i位置。
             *
             * 当 flip 为1，表示翻转过了，而原数组 A[i] 为1，表示虽然原来是1，但是当前位置受之前翻转的影响变成了0，此时就需要翻转回来。
             *
             *
             */
            if (A[i] == flip) {
                // 我们翻转了子数组 A[i] 至 A[i+K-1] 并且给这个操作加1
                ans++;
                /**
                 * 判断我们是否还能翻转K个大小的连续子数组 其实也就是i+k是否大于N ,如果不能的话 就返回-1
                 */
                if (i + K > N) return -1;
                /**
                 * flip 当前的值 一定等于0
                 * 因为等于0的话 才是我们翻转数组的条件
                 * 其实这里的话 目的就是为了 设置flip 为 1
                 *
                 */
                flip ^= 1;
                /**
                 *
                 * 将翻转数组的最末尾设置为翻转状态(原本的状态是0 和 1异或之后的结果变成了1)
                 *
                 *
                 * 这里记录一下 翻转的最末尾是为了在出了i+k 这个范围后 再异或一下 将flip的值从进入i这个翻转开始的影响给去掉
                 *
                 */
                if (i + K < N) hint[i + K] ^= 1;
            }
        }

        return ans;
    }

}
